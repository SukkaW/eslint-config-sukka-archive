import * as chalk from 'chalk';
import { writeFileSync } from 'fs';
import { Linter } from 'eslint';

import { format, resolveConfig } from 'prettier';
import * as eslintConfigSukka from '../node';

import typescriptESLintBuiltinRules from '@typescript-eslint/eslint-plugin/dist/rules';
import { overrides as typescriptESLintBuiltinOverrides } from '@typescript-eslint/eslint-plugin/dist/configs/eslint-recommended';

import * as sukkaBestPracticesRules from '../rules/best-practices';
import * as sukkaErrorRules from '../rules/error';
import * as sukkaEs6Rules from '../rules/es6';
import * as sukkaStyleRules from '../rules/style';
import * as sukkaVariablesRules from '../rules/variables';
import * as sukkaTypeScriptRules from '../rules/typescript';

interface LinterConfigRules {
  [name: string]: any
}

const eslintLinter = new Linter();
const prettierConfig = resolveConfig.sync(__dirname);

const SUKKA_RULES_ENTRIES = new Map(Object.entries({
  ...sukkaBestPracticesRules,
  ...sukkaErrorRules,
  ...sukkaEs6Rules,
  ...sukkaStyleRules,
  ...sukkaVariablesRules,
  ...sukkaTypeScriptRules
}));

const TS_ESLINT_RULE_NAME_PREFIX = '@typescript-eslint/';

const ESLINT_BASE_RULES_TO_BE_OVERRIDDEN = new Map(
  Object.entries(typescriptESLintBuiltinRules)
    .filter(([, rule]) => rule.meta.docs?.extendsBaseRule)
    .map(([ruleName, rule]) => [
      ruleName,
      typeof rule.meta.docs?.extendsBaseRule === 'string'
        ? rule.meta.docs?.extendsBaseRule
        : ruleName,
    ] as const)
);

const BASE_TS_CONFIG = {
  plugins: ['@typescript-eslint'],
  parser: '@typescript-eslint/parser',
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  /**
   * This is a compatibility ruleset that:
   * - disables rules from eslint:recommended which are already handled by TypeScript.
   * - enables rules that make sense due to TS's typechecking / transpilation.
   */
  overrides: typescriptESLintBuiltinOverrides
}

const generatedTsConfigRules: LinterConfigRules = {
  ...sukkaBestPracticesRules,
  ...sukkaErrorRules,
  ...sukkaEs6Rules,
  ...sukkaStyleRules,
  ...sukkaVariablesRules,
  ...sukkaTypeScriptRules
};

console.log('========== generate typescript.js ==========')

SUKKA_RULES_ENTRIES.forEach((ruleConfig, ruleName) => {
  if (ESLINT_BASE_RULES_TO_BE_OVERRIDDEN.has(ruleName)) {
    console.log(`${chalk.yellow('eslint:recommended')} ${chalk.green(ruleName)} needs to be overridden by ${chalk.yellow('plugin:@typescript-eslint/recommended')}`);

    generatedTsConfigRules[ruleName] = 'off';
    generatedTsConfigRules[`${TS_ESLINT_RULE_NAME_PREFIX}${ruleName}`] = ruleConfig;
  }
});

// Handle "camelcase" seperatelly
console.log(`${chalk.yellow('eslint:recommended')} ${chalk.green('camelcase')} needs to be turn off mannually`);
generatedTsConfigRules.camelcase = 'off';

writeConfig({
  ...BASE_TS_CONFIG,
  rules: generatedTsConfigRules
}, 'typescript.js');

function addAutoGeneratedComment(code: string): string {
  return [
    '// THIS CODE WAS AUTOMATICALLY GENERATED',
    '// DO NOT EDIT THIS CODE BY HAND',
    '// YOU CAN REGENERATE IT USING npm run build',
    '',
    code,
  ].join('\n');
}

/**
 * Helper function writes configuration.
 */
function writeConfig(config, filePath: string): void {
  // note: we use `export =` because ESLint will import these configs via a commonjs import
  const code = `module.exports = ${JSON.stringify(config)}`;

  const configStr = eslintLinter.verifyAndFix(
    format(addAutoGeneratedComment(code), {
      parser: 'babel',
      ...prettierConfig
    }),
    eslintConfigSukka
  );

  writeFileSync(filePath, configStr.output);
}
